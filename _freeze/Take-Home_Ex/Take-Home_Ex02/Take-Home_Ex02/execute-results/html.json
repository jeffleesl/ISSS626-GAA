{
  "hash": "09ab95f1355517940af7a3324b772c34",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take Home Exercise 2 : Discovering impacts of COVID-19 on Thailand tourism economy at the province level using spatial and spatio-temporal statistics\"\nauthor: \"Jeffrey Lee Shao Lin\"\ndate: \"September 27, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n  warning: false\n---\n\n\n# 1. Setting the Scene\n\nTourism is one of Thailand’s largest industries, accounting for some 20% of the gross domestic product (GDP). In 2019, Thailand earned 90 billion US\\$ from domestic and international tourism, but the COVID-19 pandemic caused revenues to crash to 24 billion US\\$ in 2020.\n\nFigure below shows the total revenue receipt from tourism sector from January 2019 until Feb 2023. The figure reveals that the revenue from tourism industry have been recovered gradually since September 2021.\n\n![](images/clipboard-378385426.png)\n\nHowever, it is important to note that the tourism economy of Thailand are not evenly distributed. Figure below reveals that the tourism economy of Thailand are mainly focus on five provinces, namely Bangkok, Phuket, Chiang Mai, Sukhothai and Phetchaburi.\n\n![](images/clipboard-986836251.png)\n\n# 2. Objectives\n\nAs a a curious geospatial analytics green horn, we are interested to discover:\n\n-   if the key indicators of tourism economy of Thailand are independent from space and space and time.\n\n-   If the tourism economy is indeed spatial and spatio-temporal dependent, then, you would like to detect where are the clusters and outliers, and the emerging hot spot/cold spot areas.\n\n# 3. The Task\n\nThe specific tasks of this take-home exercise are as follows:\n\nUsing appropriate function of sf and tidyverse, preparing the following geospatial data layer: a study area layer in sf polygon features. It must be at province level (including Bangkok) of Thailand. a tourism economy indicators layer within the study area in sf polygon features. a derived tourism economy indicator layer in spacetime s3 class of sfdep. Keep the time series at month and year levels. Using the extracted data, perform global spatial autocorrelation analysis by using sfdep methods. Using the extracted data, perform local spatial autocorrelation analysis by using sfdep methods. Using the extracted data, perform emerging hotspot analysis by using sfdep methods. Describe the spatial patterns revealed by the analysis above.\n\n# 4. The Data\n\nFor the purpose of this take-home exercise, two data sets shall be used, they are:\n\nThailand Domestic Tourism Statistics at Kaggle. You are required to use version 2 of the data set.\n\nThailand - Subnational Administrative Boundaries at HDX. You are required to use the province boundary data set.\n\n# 5. Importing Packages\n\nBefore we start the exercise, we will need to import necessary R packages first. We will use the following packages:\n\n-   [sf](https://r-spatial.github.io/sf/index.html) package provides functions to manage, processing, and manipulate **Simple Features**, a formal geospatial data standard that specifies a storage and access model of spatial geometries such as points, lines, and polygons.\n\n-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html) which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using [leaflet](https://leafletjs.com/) API.\n\n-   [**sfdep**](https://cran.r-project.org/web/packages/sfdep/index.html) which provide functions for utilizes list columns extensively to make this interface possible.\n\n-   [**smoothr**](https://cran.r-project.org/web/packages/smoothr/index.html) which provide functions for smoothing and tidying spatial features (i.e. lines and polygons) to make them more aesthetically pleasing.\n\n-   [**lubridate**](https://cran.r-project.org/web/packages/lubridate/index.html) which provide functions to work with date-times and time-spans: fast and user friendly parsing of date-time data, extraction and updating of components of a date-time (years, months, days, hours, minutes, and seconds), algebraic manipulation on date-time and time-span objects.\n\n-   [`ggplot2`](https://cran.r-project.org/web/packages/ggplot2/) which create advanced visualisations, graphics and maps using the Grammar of Graphics.\n\n-   [`Kendall`](https://cran.r-project.org/web/packages/Kendall/) which compute the Kendall rank correlation and Mann-Kendall trend test.\n\n    Use the code chunk below to install and launch the below R packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, spdep, tmap, lubridate, plotly, tidyverse, ggplot2, Kendall)\n```\n:::\n\n\n# 6. Getting the Data Into R Environment\n\nIn this section, we will learn how to bring a geospatial data and its associated attribute table into R environment. The geospatial data is in ESRI shapefile format and the attribute table is in csv fomat.\n\n## 6.1 Import shapefile into r environment\n\n### 6.1.1 Thailand Domestic Tourism Statistics\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntourism_data <- read_csv(\"data/rawdata/thailand_domestic_tourism_2019_2023_ver2.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(tourism_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 30,800\nColumns: 7\n$ date          <date> 2019-01-01, 2019-01-01, 2019-01-01, 2019-01-01, 2019-01…\n$ province_thai <chr> \"กรุงเทพมหานคร\", \"ลพบุรี\", \"พระนครศรีอยุธยา\", \"สระบุรี\", \"ชัยนาท…\n$ province_eng  <chr> \"Bangkok\", \"Lopburi\", \"Phra Nakhon Si Ayutthaya\", \"Sarab…\n$ region_thai   <chr> \"ภาคกลาง\", \"ภาคกลาง\", \"ภาคกลาง\", \"ภาคกลาง\", \"ภาคกลาง\", \"…\n$ region_eng    <chr> \"central\", \"central\", \"central\", \"central\", \"central\", \"…\n$ variable      <chr> \"ratio_tourist_stay\", \"ratio_tourist_stay\", \"ratio_touri…\n$ value         <dbl> 93.37, 61.32, 73.37, 67.33, 79.31, 71.70, 64.65, 71.21, …\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntourism_data$variable <- as.factor(tourism_data$variable)\nlevels(tourism_data$variable)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"no_tourist_all\"     \"no_tourist_foreign\" \"no_tourist_stay\"   \n[4] \"no_tourist_thai\"    \"ratio_tourist_stay\" \"revenue_all\"       \n[7] \"revenue_foreign\"    \"revenue_thai\"      \n```\n\n\n:::\n:::\n\n\nVariables:\n\n|                      |                                                                             |\n|--------------------------|----------------------------------------------|\n| `no_tourist_all`     | The total number of domestic tourists who visited the province              |\n| `no_tourist_foreign` | The number of foreign tourists who visited the province                     |\n| `no_tourist_stay`    | The number of tourists who stay over-night                                  |\n| `no_tourist_thai`    | The number of Thai tourists who visited the province                        |\n| `ratio_tourist_stay` | The ratio of tourist stay over-night.                                       |\n| `revenue_all`        | The revenue generated by the tourism industry in the province, in Thai Baht |\n| `revenue_foreign`    | The revenue generated by foreign tourists in the province, in Thai Baht     |\n| `revenue_thai`       | The revenue generated by Thai tourists in the province, in Thai Baht        |\n\n#### 6.1.1.2 Reshape the Data\n\nUse pivot_wider to create new columns based on the variables in Column F, using Column G as the values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntourism_data_wide <- tourism_data %>%\n  pivot_wider(\n    names_from = variable,\n    values_from = value,\n    values_fill = NA  # Fill missing values with NA \n    )  #%>% \n  #filter(!is.na(revenue_all) & revenue_all != 0)\n\ntourism_data_wide\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,850 × 13\n   date       province_thai province_eng             region_thai region_eng\n   <date>     <chr>         <chr>                    <chr>       <chr>     \n 1 2019-01-01 กรุงเทพมหานคร  Bangkok                  ภาคกลาง     central   \n 2 2019-01-01 ลพบุรี          Lopburi                  ภาคกลาง     central   \n 3 2019-01-01 พระนครศรีอยุธยา Phra Nakhon Si Ayutthaya ภาคกลาง     central   \n 4 2019-01-01 สระบุรี         Saraburi                 ภาคกลาง     central   \n 5 2019-01-01 ชัยนาท         Chainat                  ภาคกลาง     central   \n 6 2019-01-01 นครปฐม        Nakhon Pathom            ภาคกลาง     central   \n 7 2019-01-01 สิงห์บุรี         Sing Buri                ภาคกลาง     central   \n 8 2019-01-01 อ่างทอง        Ang Thong                ภาคกลาง     central   \n 9 2019-01-01 นนทบุรี         Nonthaburi               ภาคกลาง     central   \n10 2019-01-01 ปทุมธานี        Pathum Thani             ภาคกลาง     central   \n# ℹ 3,840 more rows\n# ℹ 8 more variables: ratio_tourist_stay <dbl>, no_tourist_stay <dbl>,\n#   no_tourist_all <dbl>, no_tourist_thai <dbl>, no_tourist_foreign <dbl>,\n#   revenue_all <dbl>, revenue_thai <dbl>, revenue_foreign <dbl>\n```\n\n\n:::\n:::\n\n\n#### 6.1.1.2 Select Relevant Columns\n\nAfter reshaping, select only the relevant columns (`revenue_all`) for your analysis. Also, create new columns for year, month, day, month factor and month-year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntourism_data_new <- tourism_data_wide %>%\n  select(date, province_thai, province_eng, region_eng, revenue_all) %>%\n  mutate(\n    #continuous_month = (as.numeric(format(date, \"%Y\")) - 2019) * 12 + as.numeric(format(date, \"%m\")),\n    Year_num = year(date),  # Extract the year\n    Month_num = month(date),  # Extract numeric month\n    Month_fac = month(date, label = TRUE, abbr = TRUE),  # Extract abbreviated month as factor\n     Month_year = factor(format(date, \"%b-%Y\"), \n                                levels = format(seq(min(date), max(date), by = \"month\"), \"%b-%Y\"))  # Create 'month-year' string\n  )\n\nprint(tourism_data_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,850 × 9\n   date       province_thai province_eng         region_eng revenue_all Year_num\n   <date>     <chr>         <chr>                <chr>            <dbl>    <dbl>\n 1 2019-01-01 กรุงเทพมหานคร  Bangkok              central    81926490000     2019\n 2 2019-01-01 ลพบุรี          Lopburi              central      457240000     2019\n 3 2019-01-01 พระนครศรีอยุธยา Phra Nakhon Si Ayut… central     1438730000     2019\n 4 2019-01-01 สระบุรี         Saraburi             central      347790000     2019\n 5 2019-01-01 ชัยนาท         Chainat              central      101790000     2019\n 6 2019-01-01 นครปฐม        Nakhon Pathom        central      407980000     2019\n 7 2019-01-01 สิงห์บุรี         Sing Buri            central       69610000     2019\n 8 2019-01-01 อ่างทอง        Ang Thong            central      132070000     2019\n 9 2019-01-01 นนทบุรี         Nonthaburi           central      527420000     2019\n10 2019-01-01 ปทุมธานี        Pathum Thani         central      307920000     2019\n# ℹ 3,840 more rows\n# ℹ 3 more variables: Month_num <dbl>, Month_fac <ord>, Month_year <fct>\n```\n\n\n:::\n:::\n\n\n### 6.1.2 Thailand - Subnational Administrative Boundaries\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load province boundaries\n\nprovinces <- st_read(dsn = \"data/rawdata\", \n                layer = \"tha_admbnda_adm1_rtsd_20220121\") %>%\n  st_transform(crs = 32647) %>%\n  mutate(ADM1_EN = recode(ADM1_EN, # Update province boundaries' name\n    \"Lop Buri\" = \"Lopburi\",\n    \"Chai Nat\" = \"Chainat\",\n    \"Chon Buri\" = \"Chonburi\",\n    \"Prachin Buri\" = \"Prachinburi\",\n    \"Phangnga\" = \"Phang Nga\",\n    \"Buri Ram\" = \"Buriram\",\n    \"Si Sa Ket\" = \"Sisaket\",\n    \"Nong Bua Lam Phu\" = \"Nong Bua Lamphu\"\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `tha_admbnda_adm1_rtsd_20220121' from data source \n  `C:\\Users\\user\\OneDrive - Singapore Management University\\MITB\\6. Geospatial Analytics and Applications\\jeffleesl\\ISSS626-GAA\\Take-Home_Ex\\Take-Home_Ex02\\data\\rawdata' \n  using driver `ESRI Shapefile'\nSimple feature collection with 77 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 97.34336 ymin: 5.613038 xmax: 105.637 ymax: 20.46507\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load province boundaries\n\nglimpse(provinces)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 77\nColumns: 17\n$ Shape_Leng <dbl> 2.417227, 1.695100, 1.251111, 1.884945, 3.041716, 1.739908,…\n$ Shape_Area <dbl> 0.13133873, 0.07926199, 0.05323766, 0.12698345, 0.21393797,…\n$ ADM1_EN    <chr> \"Bangkok\", \"Samut Prakan\", \"Nonthaburi\", \"Pathum Thani\", \"P…\n$ ADM1_TH    <chr> \"กรุงเทพมหานคร\", \"สมุทรปราการ\", \"นนทบุรี\", \"ปทุมธานี\", \"พระนครศรีอ…\n$ ADM1_PCODE <chr> \"TH10\", \"TH11\", \"TH12\", \"TH13\", \"TH14\", \"TH15\", \"TH16\", \"TH…\n$ ADM1_REF   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ADM1ALT1EN <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ADM1ALT2EN <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ADM1ALT1TH <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ADM1ALT2TH <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ADM0_EN    <chr> \"Thailand\", \"Thailand\", \"Thailand\", \"Thailand\", \"Thailand\",…\n$ ADM0_TH    <chr> \"ประเทศไทย\", \"ประเทศไทย\", \"ประเทศไทย\", \"ประเทศไทย\", \"ประเทศ…\n$ ADM0_PCODE <chr> \"TH\", \"TH\", \"TH\", \"TH\", \"TH\", \"TH\", \"TH\", \"TH\", \"TH\", \"TH\",…\n$ date       <date> 2019-02-18, 2019-02-18, 2019-02-18, 2019-02-18, 2019-02-18…\n$ validOn    <date> 2022-01-22, 2022-01-22, 2022-01-22, 2022-01-22, 2022-01-22…\n$ validTo    <date> -001-11-30, -001-11-30, -001-11-30, -001-11-30, -001-11-30…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((674339.8 15..., MULTIPOLYGON (…\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(provinces) +\n  tm_polygons()\n```\n:::\n\n\n![](images/clipboard-2693720629.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Convert to multipolygon to individual polygon\nprovinces_sf <- provinces %>% \n  st_cast(\"POLYGON\") %>% \n  mutate(area = st_area(.))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Group by the unique name and select the largest polygon by area\nprovinces_cleaned <- provinces_sf %>% \n  group_by(ADM1_EN) %>% \n  filter(area == max(area)) %>% \n  ungroup() %>% \n  select(-area) %>% \n  select(ADM1_EN)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(provinces_cleaned) +\n  tm_polygons()\n```\n:::\n\n\n![](images/clipboard-438579653.png)\n\n## 6.2 Performing relational join\n\nThe code chunk below will be used to update the attribute table of *provinces*’ SpatialPolygonsDataFrame with the attribute fields of *tourismdatanew* dataframe. This is performed by using *left_join()* of **dplyr** package.\n\n### 6.2.1 Using Province in English\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Left join to add geometries from thailand boundaries shapefile\ntourism_sf <- tourism_data_new %>%\n  left_join(provinces_cleaned, by = c(\"province_eng\" = \"ADM1_EN\")) \n\n# Ensure the data is a valid sf object\ntourism_sf <- st_as_sf(tourism_sf)\n\n# Check if transformation was successful\nst_crs(tourism_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:32647 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 47N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 47N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",99,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Navigation and medium accuracy spatial referencing.\"],\n        AREA[\"Between 96°E and 102°E, northern hemisphere between equator and 84°N, onshore and offshore. China. Indonesia. Laos. Malaysia - West Malaysia. Mongolia. Myanmar (Burma). Russian Federation. Thailand.\"],\n        BBOX[0,96,84,102]],\n    ID[\"EPSG\",32647]]\n```\n\n\n:::\n:::\n\n\n### 6.2.2 Using Province in Thai (Showing Other Method)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Left join to add geometries from thailand boundaries shapefile\ntourism_sf_th <- tourism_data_new %>%\n  left_join(provinces, by = c(\"province_thai\" = \"ADM1_TH\"))\n\n# Ensure the data is a valid sf object\ntourism_sf_th <- st_as_sf(tourism_sf_th)\n\n# Check if transformation was successful\nst_crs(tourism_sf_th)\n```\n:::\n\n\n# 7.Derived Tourism Economy Indicator Layer\n\nIt is always a good practice to use set.seed() before performing simulation. This is to ensure that the computation is reproducible.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n## 7.1 Plotting a choropleth map\n\nPlot a choropleth map showing the distribution of revenue generated by the tourism industry in the different province, in Thai Baht\n\n### 7.1.1 Split into pre-covid (Year 2019), during covid (Year 2020-2022) and post covid (year 2023)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter for the year 2019\ntourism_sf_2019 <- tourism_sf %>%\n  filter(Year_num == 2019)\n\n# Filter for the year 2020\ntourism_sf_2020 <- tourism_sf %>%\n  filter(Year_num == 2020)\n\n# Filter for the year 2021\ntourism_sf_2021 <- tourism_sf %>%\n  filter(Year_num == 2021)\n\n# Filter for the year 2022\ntourism_sf_2022 <- tourism_sf %>%\n  filter(Year_num == 2022)\n\n# Filter for the year 2023\ntourism_sf_2023 <- tourism_sf %>%\n  filter(Year_num == 2023)\n```\n:::\n\n\n#### 7.1.1.1 Pre-COVID (Year 2019)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(tourism_sf_2019) +\n  tm_fill(\"revenue_all\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          title = \"Total Revenue\") +\n  tm_borders(col = \"grey\") +\n  tm_facets(\"Month_year\") +\n  tm_layout(main.title = \"Distribution of revenue generated by the tourism industry \\n in the different provinces in Year 2019 (Pre-COVID)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)\n```\n:::\n\n\n![](images/clipboard-179134376.png)\n\n#### 7.1.1.2 During COVID (Year 2020-2022)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(tourism_sf_2020) +\n  tm_fill(\"revenue_all\",\n          style = \"quantile\",\n          palette = \"Oranges\",\n          title = \"Total Revenue\") +\n  tm_borders(col = \"grey\") +\n  tm_facets(\"Month_year\") +\n  tm_layout(main.title = \"Distribution of revenue generated by the tourism industry \\n in the different provinces in Year 2020 (During COVID)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)\n```\n:::\n\n\n![](images/clipboard-2780944027.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(tourism_sf_2021) +\n  tm_fill(\"revenue_all\",\n          style = \"quantile\",\n          palette = \"Greens\",\n          title = \"Total Revenue\") +\n  tm_borders(col = \"grey\") +\n  tm_facets(\"Month_year\") +\n  tm_layout(main.title = \"Distribution of revenue generated by the tourism industry \\n in the different provinces in Year 2021 (During COVID)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)\n```\n:::\n\n\n![](images/clipboard-2152806592.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(tourism_sf_2022) +\n  tm_fill(\"revenue_all\",\n          style = \"quantile\",\n          palette = \"Reds\",\n          title = \"Total Revenue\") +\n  tm_borders(col = \"grey\") +\n  tm_facets(\"Month_year\") +\n  tm_layout(main.title = \"Distribution of revenue generated by the tourism industry \\n in the different provinces in Year 2022 (During COVID)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)\n```\n:::\n\n\n![](images/clipboard-3578708423.png)\n\n#### 7.1.1.3 Post COVID (Year 2023)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(tourism_sf_2023) +\n  tm_fill(\"revenue_all\",\n          style = \"quantile\",\n          palette = \"Purples\",\n          title = \"Total Revenue\") +\n  tm_borders(col = \"grey\") +\n  tm_facets(\"Month_year\") +\n  tm_layout(main.title = \"Distribution of revenue generated by the tourism industry \\n in the different provinces in Year 2023 (Post COVID)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)\n```\n:::\n\n\n![](images/clipboard-1374487177.png)\n\n### 7.1.2 Calculate the Average Revenue for Each Province\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate the average revenue_all for each province\n\n# Year 2019\ntourism_sf_avg_2019 <- tourism_sf_2019 %>%\n  group_by(province_eng) %>%\n  summarize(average_revenue_all = mean(revenue_all, na.rm = TRUE))\n\n# Year 2020\ntourism_sf_avg_2020 <- tourism_sf_2020 %>%\n  group_by(province_eng) %>%\n  summarize(average_revenue_all = mean(revenue_all, na.rm = TRUE))\n\n# Year 2021\ntourism_sf_avg_2021 <- tourism_sf_2021 %>%\n  group_by(province_eng) %>%\n  summarize(average_revenue_all = mean(revenue_all, na.rm = TRUE))\n\n# Year 2022\ntourism_sf_avg_2022 <- tourism_sf_2022 %>%\n  group_by(province_eng) %>%\n  summarize(average_revenue_all = mean(revenue_all, na.rm = TRUE))\n# Year 2023\ntourism_sf_avg_2023 <- tourism_sf_2023 %>%\n  group_by(province_eng) %>%\n  summarize(average_revenue_all = mean(revenue_all, na.rm = TRUE))\n```\n:::\n\n\n### 7.1.3 Join the Average Revenue Back to the Spatial Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Join the average revenue back to the spatial data\n\n# Year 2019\nall_tourism_sf_avg_2019 <- left_join(st_drop_geometry(tourism_sf_2019), tourism_sf_avg_2019, by = \"province_eng\")\nall_tourism_sf_avg_2019 <- st_as_sf(all_tourism_sf_avg_2019)\n\n# Year 2020\nall_tourism_sf_avg_2020 <- left_join(st_drop_geometry(tourism_sf_2020), tourism_sf_avg_2020, by = \"province_eng\")\nall_tourism_sf_avg_2020 <- st_as_sf(all_tourism_sf_avg_2020)\n\n# Year 2021\nall_tourism_sf_avg_2021 <- left_join(st_drop_geometry(tourism_sf_2021), tourism_sf_avg_2021, by = \"province_eng\")\nall_tourism_sf_avg_2021 <- st_as_sf(all_tourism_sf_avg_2021)\n\n# Year 2022\nall_tourism_sf_avg_2022 <- left_join(st_drop_geometry(tourism_sf_2022), tourism_sf_avg_2022, by = \"province_eng\")\nall_tourism_sf_avg_2022 <- st_as_sf(all_tourism_sf_avg_2022)\n\n# Year 2023\nall_tourism_sf_avg_2023 <- left_join(st_drop_geometry(tourism_sf_2023), tourism_sf_avg_2023, by = \"province_eng\")\nall_tourism_sf_avg_2023 <- st_as_sf(all_tourism_sf_avg_2023)\n```\n:::\n\n\n### 7.1.4 Modify the Plot Code to Use average_revenue_all\n\n#### 7.1.4.1 Pre-COVID (Year 2019)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(all_tourism_sf_avg_2019) +\n  tm_fill(\"average_revenue_all\",   # Use average revenue\n          style = \"quantile\",      # Use quantile classification\n          palette = \"Blues\",       # Choose color palette\n          title = \"Average Revenue (All)\") +\n  tm_borders(col = \"grey\") +\n  tm_facets(\"Month_year\") +\n  tm_layout(main.title = \"Average Revenue Generated by Tourism Industry in \\n Different Provinces in Year 2019 (Pre-COVID)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)\n```\n:::\n\n\n![](images/clipboard-2046035017.png)\n\n#### 7.1.1.2 During COVID (Year 2020-2022)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(all_tourism_sf_avg_2020) +\n  tm_fill(\"average_revenue_all\",   # Use average revenue\n          style = \"quantile\",      # Use quantile classification\n          palette = \"Oranges\",       # Choose color palette\n          title = \"Average Revenue (All)\") +\n  tm_borders(col = \"grey\") +\n  tm_facets(\"Month_year\") +\n  tm_layout(main.title = \"Average Revenue Generated by Tourism Industry in \\n Different Provinces in Year 2020 (During COVID)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)\n```\n:::\n\n\n![](images/clipboard-3648537494.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(all_tourism_sf_avg_2021) +\n  tm_fill(\"average_revenue_all\",   # Use average revenue\n          style = \"quantile\",      # Use quantile classification\n          palette = \"Greens\",       # Choose color palette\n          title = \"Average Revenue (All)\") +\n  tm_borders(col = \"grey\") +\n  tm_facets(\"Month_year\") +\n  tm_layout(main.title = \"Average Revenue Generated by Tourism Industry in \\n Different Provinces in Year 2021 (During COVID)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)\n```\n:::\n\n\n![](images/clipboard-1267374598.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(all_tourism_sf_avg_2022) +\n  tm_fill(\"average_revenue_all\",   # Use average revenue\n          style = \"quantile\",      # Use quantile classification\n          palette = \"Reds\",       # Choose color palette\n          title = \"Average Revenue (All)\") +\n  tm_borders(col = \"grey\") +\n  tm_facets(\"Month_year\") +\n  tm_layout(main.title = \"Average Revenue Generated by Tourism Industry in \\n Different Provinces in Year 2022 (During COVID)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)\n```\n:::\n\n\n![](images/clipboard-4034122314.png)\n\n#### 7.1.1.3 Post COVID (Year 2023)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(all_tourism_sf_avg_2023) +\n  tm_fill(\"average_revenue_all\",   # Use average revenue\n          style = \"quantile\",      # Use quantile classification\n          palette = \"Purples\",       # Choose color palette\n          title = \"Average Revenue (All)\") +\n  tm_borders(col = \"grey\") +\n  tm_facets(\"Month_year\") +\n  tm_layout(main.title = \"Average Revenue Generated by Tourism Industry in \\n Different Provinces in Year 2023 (Post COVID)\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)\n```\n:::\n\n\n![](images/clipboard-3428045628.png)\n\n# 9. Global Spatial Autocorrelation Analysis\n\nThe analysis highlights that revenue and average revenue generated by the tourism industry were significantly higher in the pre-COVID period (Year 2019) compared to the COVID period and the post-COVID period (Year 2020-2023). The tourism board would likely aim to restore revenue levels to those observed before the pandemic. Before proceeding to the Global Spatial Autocorrelation Analysis, it is advisable to use the average revenue generated by the tourism industry in 2019 as a benchmark.\n\n## 9.1 Deriving Queen’s contiguity weights: sfdep methods\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- tourism_sf_avg_2019 %>%\n  mutate(\n        nb = st_contiguity(geometry),   # Calculate neighbors using Queen's contiguity\n        wt = st_weights(nb, style = \"W\", allow_zero = TRUE),  # Calculate weights with style \"W\", allowing zero for zones without neighbors\n        .before = 1\n    )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 77 features and 4 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 325178.8 ymin: 620860.6 xmax: 1213656 ymax: 2263241\nProjected CRS: WGS 84 / UTM zone 47N\n# A tibble: 77 × 5\n   nb        wt     province_eng  average_revenue_all                   geometry\n * <nb>      <list> <chr>                       <dbl>              <POLYGON [m]>\n 1 <int [3]> <dbl>  Amnat Charoen           36607500  ((1137720 1809629, 113772…\n 2 <int [4]> <dbl>  Ang Thong               84460000  ((643472.8 1636469, 64349…\n 3 <int [6]> <dbl>  Bangkok              88984480000  ((674339.8 1543300, 67438…\n 4 <int [3]> <dbl>  Bueng Kan               89196667. ((965496 2045531, 965625.…\n 5 <int [5]> <dbl>  Buriram                391995833. ((921217 1750212, 921217 …\n 6 <int [8]> <dbl>  Chachoengsao           423815000  ((722656.1 1546054, 72279…\n 7 <int [4]> <dbl>  Chainat                111380000  ((620165.4 1704256, 62029…\n 8 <int [4]> <dbl>  Chaiyaphum             183593333. ((772997.4 1851276, 77310…\n 9 <int [5]> <dbl>  Chanthaburi            726153333. ((839085.8 1476451, 83909…\n10 <int [5]> <dbl>  Chiang Mai            9222527500  ((554883.3 2226795, 55500…\n# ℹ 67 more rows\n```\n\n\n:::\n:::\n\n\n## 9.2 Computing Global Moran’ I\n\nIn the code chunk below, global_moran() function is used to compute the Moran’s I value. Different from spdep package, the output is a tibble data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoranI <- global_moran(wm_q$average_revenue_all,\n                       wm_q$nb,\n                       wm_q$wt,\n                  zero.policy=TRUE)\nglimpse(moranI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ I: num -0.0296\n $ K: num 48.2\n```\n\n\n:::\n:::\n\n\nSince I is slightly negative (−0.0296), it suggests weak dispersion or no significant spatial pattern in the `average_revenue_all` variable across the geographic entities.\n\nK=48.2 refers to the total number of observations used in the calculation.\n\n## 9.3 Performing Global Moran’sI test\n\nIn general, Moran’s I test will be performed instead of just computing the Moran’s I statistics. With sfdep package, Moran’s I test can be performed by using global_moran_test() as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_test(wm_q$average_revenue_all,\n                  wm_q$nb,\n                  wm_q$wt,\n                  zero.policy=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw  \nn reduced by no-neighbour observations  \n\nMoran I statistic standard deviate = -0.34222, p-value = 0.6339\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     -0.029251263      -0.013333333       0.002163547 \n```\n\n\n:::\n:::\n\n\nThe Moran's I statistic is −0.02925, slightly negative and close to zero. This aligns with the earlier result, indicating weak dispersion or no significant spatial autocorrelation. This is is not statistically significant (p-value =0.6339).\n\nThere is insufficient evidence to reject the null hypothesis of spatial randomness for the variable `average_revenue_all`.\n\nThe spatial distribution of `average_revenue_all` appears random, with no meaningful clustering or dispersion.\n\n## 9.4 Global Moran’I permutation test\n\nNext, global_moran_perm() is used to perform Monte Carlo simulation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$average_revenue_all,\n                  wm_q$nb,\n                  wm_q$wt,\n                  zero.policy=TRUE,\n                  nsim =99)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = -0.029251, observed rank = 48, p-value = 0.96\nalternative hypothesis: two.sided\n```\n\n\n:::\n:::\n\n\nThe statistical report on previous tab shows that the p-value is bigger than alpha value of 0.05. Hence, we have not enough statistical evidence to reject the null hypothesis that the spatial distribution of total revenue are resemble random distribution (i.e. independent from spatial). Because the Moran’s I statistics is lesser than 0. We can infer that the spatial distribution shows no sign of clustering.\n\n# 10. Local Spatial Autocorrelation Analysis\n\n## 10.1 Computing local Moran’s I\n\nIn this section, we compute Local Moran’s I of total revenue at province level by using local_moran() of sfdep package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa <- wm_q %>%\n mutate(local_moran = local_moran(\n  average_revenue_all, nb, wt, zero.policy=TRUE, nsim = 99),\n    .before = 1) %>%\n  unnest(local_moran)\n```\n:::\n\n\n## 10.2 Visualising local Moran’s I\n\nIn this code chunk below, tmap functions are used prepare a choropleth map by using value in the ii field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(lisa) +\n  tm_fill(\"ii\") +\n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(\n    main.title = \"local Moran's I of \\n Total Average Revenue\",\n    main.title.size = 2)\n```\n:::\n\n\n![](images/clipboard-194156232.png)\n\n## 10.3 Visualising p-value of local Moran’s I\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#tmap_mode(\"plot\")\n#tm_shape(lisa) +\n  #tm_fill(\"p_ii_sim\") +\n  #tm_borders(alpha = 0.5) +\n  #tm_facets(\"Month_year\") +\n  #tm_layout(\n  #  main.title = \"p-values of local Moran's I\",\n  #  main.title.size = 2)\n```\n:::\n\n\n## 10.4 Visualising local Moran’s I and p-value\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#tmap_mode(\"plot\")\n#map1 <- tm_shape(lisa) +\n#  tm_fill(\"ii\") + \n # tm_borders(alpha = 0.5) +\n # tm_facets(\"Month_year\") +\n # tm_view(set.zoom.limits = c(6,8)) +\n # tm_layout(main.title = \"local Moran's I of Total Revenue\",\n   #         main.title.size = 0.8)\n\n#map2 <- tm_shape(lisa) +\n  #tm_fill(\"p_ii\",\n   #       breaks = c(0, 0.001, 0.01, 0.05, 1),\n    #          labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not sig\")) + \n # tm_borders(alpha = 0.5) +\n#  tm_facets(\"Month_year\") +\n#  tm_layout(main.title = \"p-value of local Moran's I\",\n         #   main.title.size = 0.8)\n\n#tmap_arrange(map1, map2, ncol = 2)\n```\n:::\n\n\n## 10.5 Plotting LISA map\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#lisa_sig <- lisa %>%\n # filter(p_ii < 0.05) #filter only significant p values\n\n#tmap_mode(\"plot\")\n#tm_shape(lisa)+\n # tm_polygons()+\n # tm_borders(alpha=0.5)+\n#tm_shape(lisa_sig)+\n#  tm_fill(\"mean\")+\n#  tm_borders(alpha=0.4)\n```\n:::\n\n\n## 10.6 Computing local Gi\\* statistics\n\nAs usual, we will need to derive a spatial weight matrix before we can compute local Gi\\* statistics. Code chunk below will be used to derive a spatial weight matrix by using sfdep functions and tidyverse approach.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#wm_idw <- revenue_all_sf %>% \n # mutate(nb = st_contiguity(geometry) ,\n     #    wts = st_inverse_distance(nb, geometry,\n       #                           scale = 1,\n       #                           alpha =1),\n       #  .before = 1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#wm_idw <- revenue_all_sf %>%\n # mutate(nb = include_self(\n  #  st_contiguity(geometry)),\n  #  wts = st_inverse_distance(nb, \n        #                      geometry, \n        #                      scale = 1,\n        #                      alpha = 1),\n        # .before = 1)\n```\n:::\n\n\nNow, we will compute the local Gi\\* by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# HCSA <- wm_idw %>% \n  #mutate(local_Gi = local_gstar_perm(\n   #revenue_all, nb, wts, nsim = 99),\n    #     .before = 1) %>%\n # unnest(local_Gi)\n#HCSA\n```\n:::\n\n\n### 10.6.1 Visualising Gi\\*\n\nIn the code chunk below, tmap functions are used to plot the local Gi\\* (i.e. gi_star) at the province level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#tmap_mode(\"plot\")\n#tm_shape(HCSA)+\n#  tm_fill(\"gi_star\")+\n#  tm_borders(alpha = 0.5) +\n # tm_view(set.zoom.limits = c(6,8))\n```\n:::\n\n\n### 10.6.2 Visualising p-value of HCSA\n\nIn the code chunk below, tmap functions are used to plot the p-values of local Gi\\* (i.e. p_sim) at the province level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#tmap_mode(\"plot\")\n#tm_shape(HCSA) +\n # tm_fill(\"p_sim\") + \n # tm_borders(alpha = 0.5)\n```\n:::\n\n\n### 10.6.3 Visuaising local HCSA\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tmap_mode(\"plot\")\n#map1 <- tm_shape(HCSA) +\n#  tm_fill(\"gi_star\") + \n # tm_borders(alpha = 0.5) +\n # tm_view(set.zoom.limits = c(6,8)) +\n # tm_layout(main.title = \"Gi* of GDPPC\",\n   #         main.title.size = 0.8)\n\n#map2 <- tm_shape(HCSA) +\n # tm_fill(\"p_value\",\n  #        breaks = c(0, 0.001, 0.01, 0.05, 1),\n     #         labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not sig\")) + \n#  tm_borders(alpha = 0.5) +\n#  tm_layout(main.title = \"p-value of Gi*\",\n   #         main.title.size = 0.8)\n\n#tmap_arrange(map1, map2, ncol = 2)\n```\n:::\n\n\n### 10.6.4 Visualising hot spot and cold spot areas\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#HCSA_sig <- HCSA  %>%\n # filter(p_sim < 0.05)\n#tmap_mode(\"plot\")\n#tm_shape(HCSA) +\n # tm_polygons() +\n # tm_borders(alpha = 0.5) +\n#tm_shape(HCSA_sig) +\n # tm_fill(\"cluster\") + \n  #tm_borders(alpha = 0.4)\n```\n:::\n\n\nFigure above reveals that there is one hot spot area and two cold spot areas. Interestingly, the hot spot areas coincide with the High-high cluster identifies by using local Moran’s I method in the earlier sub-section.\n\n# 11. Emerging Hotspot Analysis\n\n## 11.1 Computing Gi\\*\n\nThe code chunk below will be used to identify neighbors and to derive an inverse distance weights.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#tourism_nb <- tourism_st %>% \n#  activate(\"geometry\") %>% # activate the geometry context\n # mutate(nb = include_self( #mutate to create two new columns nb and wt, include itself\n  #  st_contiguity(geometry)),\n  #  wt = st_inverse_distance(nb,\n     #                        geometry,\n     #                        scale = 1,\n      #                       alpha = 1),\n  #  .before = 1) %>% #new derived variable in front of the table\n  #set_nbs(\"nb\") %>% \n  #set_wts(\"wt\")\n```\n:::\n\n\nWe can use these new columns to manually calculate the local Gi\\* for each location. We can do this by grouping by Year and using local_gstar_perm() of sfdep package. After which, we use unnest() to unnest gi_star column of the newly created gi_starts data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#gi_stars <- tourism_nb %>% \n # group_by(Year) %>% \n # mutate(gi_star = local_gstar_perm(\n #   revenue_all, nb, wt)) %>% \n # tidyr::unnest(gi_star)\n```\n:::\n\n\n## 11.2 Mann-Kendall Test of GI\n\nWith these Gi\\* measures we can then evaluate each location for a trend using the Mann-Kendall test. The code chunk below uses Changsha county.\n\nA **monotonic series** or function is one that only increases (or decreases) and never changes direction. So long as the function either stays flat or continues to increase, it is monotonic.\n\nH0: No monotonic trend\n\nH1: Monotonic trend is present\n\n**Interpretation**\n\n-   Reject the null-hypothesis null if the p-value is smaller than the alpha value (i.e. 1-confident level)\n\n-   Tau ranges between -1 and 1 where:\n\n    -   -1 is a perfectly decreasing series, and\n\n    -   1 is a perfectly increasing series.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#cbg <- gi_stars %>% \n # ungroup () %>% \n # filter(province_eng == \"Bangkok\") %>%\n # select(province_eng, Year, gi_star)\n```\n:::\n\n\nNext, we plot the result by using ggplot2 functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#ggplot(data = cbg,\n    #   aes(x = Year,\n    #       y = gi_star)) +\n#  geom_line() +\n#  theme_light()\n```\n:::\n\n\n## 11.3 Interactive Mann-Kendall Plot\n\nWe can also create an interactive plot by using ggplotly() of plotly package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#gp <- ggplot(data = cbg,\n #           aes(x = Year,\n  #              y = gi_star))+\n # geom_line()+\n#  theme_light()\n\n#ggplotly(p)\n```\n:::\n\n\n## 11.4 Printing Mann-Kendall test report\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#cbg %>% \n # summarise(mk = list(\n  #  unclass(\n  #    Kendall::MannKendall(gi_star)))) %>% \n # tidyr::unnest_wider(mk)\n```\n:::\n\n\nIn the above result, sl is the p-value. With reference to the results, we will reject the hypothesis null and infer that a slight upward trend.\n\n## 11.5 Mann-Kendall test data.frame\n\nWe can replicate this for each location by using group_by() of dplyr package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#ehsa <- gi_stars %>% \n # group_by(province_eng) %>% \n # summarise(mk = list(\n #   unclass(\n #     Kendall::MannKendall(gi_star)))) %>% \n # tidyr::unnest_wider(mk)\n# head(ehsa)\n```\n:::\n\n\nWe can also sort to show significant emerging hot/cold spots\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#emerging <- ehsa %>% \n # arrange(sl, abs(tau)) %>% \n # slice(1:10)\n#head(emerging)\n```\n:::\n\n\n## 11.6 Performing Emerging Hotspot Analysis\n\nLastly, we will perform EHSA analysis by using emerging_hotspot_analysis() of sfdep package. It takes a spacetime object x (i.e. GDPPC_st), and the quoted name of the variable of interest (i.e. Total Revenue) for .var argument. The k argument is used to specify the number of time lags which is set to 1 by default. Lastly, nsim map numbers of simulation to be performed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#ehsa <- emerging_hotspot_analysis(\n # x = tourism_st,\n # .var = \"GDPPC\",\n#  k = 1,\n#  nsim = 99\n#)\n```\n:::\n\n\n## 11.7 Visualising the distribution of EHSA classes\n\nIn the code chunk below, ggplot2 functions is used to reveal the distribution of EHSA classes as a bar chart.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#ggplot(data = ehsa,\n #      aes(x = classification)) +\n # geom_bar()\n```\n:::\n\n\nFigure above shows that sporadic cold spots class has the high numbers of county.\n\n## 11.8 Visualising EHSA\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#tourism_ehsa <- tourism_st %>% \n#  left_join(ehsa,\n  #          by = join_by(province_ == location))\n```\n:::\n\n\nNext, tmap functions will be used to plot a categorical choropleth map by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#tourism_sig <- tourism_ehsa %>%\n#  filter(p_value < 0.05)\n#tmap_mode(\"plot\")\n#tm_shape(hunan_ehsa) +\n#  tm_polygons()+\n#  tm_borders(alpha = 0.5) +\n#tm_shape(ehsa_sig)+\n#  tm_fill(\"classification\")+\n#  tm_borders(alpha = 0.4)\n```\n:::\n\n\n# 8. Creating a Time Series Cube\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load province boundaries\nprovinces_new <- provinces %>%\n  rename(province_eng = ADM1_EN)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntourism_st <- spacetime(tourism_sf, provinces_new,\n                       .loc_col = \"province_eng\",\n                        .time_col = \"date\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis_spacetime_cube(tourism_st)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nThe TRUE return confirms that GDPPC_st object is indeed an time-space cube.\n\n# 12. Conclusion\n\n-   **Global Autocorrelation**: A significant positive Moran's I indicates clustering of high or low values.\n\n-   **Local Autocorrelation**: Identify specific provinces with high or low values using LISA results.\n\n-   **Hotspots**: Areas with high positive Gi\\* scores are emerging hotspots, while negative scores indicate cold spots.\n\nThis framework allows us to explore spatial dependencies in Thailand's tourism economy effectively. Adjust paths and variable names according to your specific datasets.\n\nOutput is saved in rds format for future used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(tourism_sf,\"data/rds/tourism.rds\")\n```\n:::\n\n\nThe code chunk below will be used to import the save origin6_9.rds into R environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc <- read_rds(\"data/rds/tourism.rds\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}